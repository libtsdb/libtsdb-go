# 2020-02-17

Didn't spent time on libtsdb for about two weeks (due to playing WOT ...).
Double delta part on timestamp is finished, most time is spent on writing a bit stream writer/reader.

go-tsz would change the underlying byte slice so prometheus modified it because they are using mmap.
Though their iterator still need to reset to be able to use again.

## TODO

- [ ] survey: how is primitive type stored and what happens during cast
  - [ ] big endian, small endian
    - network order is big endian
    - [ ] CPU, disk? intel, amd?
  - [ ] int, unsigned int
    - the unsigned int to int conversion (why it worked in code)
    - [ ] `2s complement` as mentioned by Haiyu
    - [ ] shift behavior on signed and unsigned
  - [ ] float64
    - [ ] how is it saved
    - [ ] what happens when casting from float64 to uint64
- [ ] prometheus
  - [ ] what would happen to its xorAppender when appending time out of order
  - [ ] finalize the stream, it seems it is writing number of samples at the end of stream ...

## Endianness

https://en.wikipedia.org/wiki/Endianness

- big endian, e.g. 1024 is `2^10`, big endian `100` `0000_0000`, small endian `0000_0000` `100`
- network use big endian

> A big-endian ordering places the most significant byte first and the least significant byte last,
> while a little-endian ordering does the opposite

> big-endianness is the dominant ordering in networking protocols
> little-endianness is the dominant ordering for processor architectures and their associated memory
> File formats can use either ordering

> programming languages use big-endian digit ordering for numeric literals 
> as well as big-endian language (“left” and “right”) for bit-shift operations, 
> regardless of the endianness of the target architecture